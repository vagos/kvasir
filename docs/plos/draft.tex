\documentclass[sigplan,review,anonymous,10pt]{acmart}

% \acmSubmissionID{PAPER ID}
\renewcommand\footnotetextcopyrightpermission[1]{}
\settopmatter{printfolios=false,printacmref=false}

\usepackage{setspace}
\usepackage{enumerate}
\usepackage{algorithm2e}
\usepackage{algpseudocode}
\usepackage{graphics}
\usepackage{xparse} 
\usepackage{xspace}
\usepackage{multirow}
\usepackage{csvsimple}
\usepackage{balance}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{nicefrac}
\usepackage{siunitx}
\usepackage{array,framed}
\usepackage{booktabs}
\usepackage{color}
\usepackage{soul}
\usepackage{float}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{csquotes}
\usepackage{cleveref}
\usepackage{dirtytalk}
\usepackage{textgreek}
\usepackage{oplotsymbl}
\usepackage{listings}
\usepackage{flushend}
\usepackage{float}

\setminted{
    fontsize=\small
  }


\def\eg{{\em e.g.}, }
\def\ie{{\em i.e.}, }
\def\etc{{\em etc.}\xspace}
\def\vs{{\em vs.}\xspace}

\def\gptmodel{{GPT-4o}\xspace}

\newcommand{\todo}[1]{\hl{\textbf{TODO:} #1}\xspace}
\newcommand{\sys}{{\scshape Kv{\textalpha}sir}\xspace}
\newcommand{\rf}[1]{\ref{#1}}
\newcommand{\sx}[1]{(\S\ref{#1})}
\newcommand{\cf}[1]{(\emph{Cf}.\S\ref{#1})}
\newcommand{\se}[1]{\S\ref{#1}}
\newcommand{\fg}[1]{Fig.~\ref{#1}}
\newcommand{\heading}[1]{\vspace{2pt}\noindent\textbf{\emph{#1}}:\enspace}
\newcommand{\ttt}[1]{\texttt{#1}\xspace}
\newcommand{\xxx}{\colorbox{red!30}{xxx}\xspace}
\definecolor{lightperiwinkle}{rgb}{0.85, 0.97, 1.0}
\newcommand{\prop}[1]{\setlength{\fboxsep}{1.75pt}\colorbox{lightperiwinkle}{\texttt{#1}}}
\newcommand{\promptbox}[1]{%
  \vspace{0.5em}%
  \hspace*{-0.0135\columnwidth}%
  \fbox{%
    \parbox[t]{0.95\columnwidth}{\tt #1}%
  }%
  \vspace{0.5em} % adjust this value as desired
}

\crefformat{section}{\S#2#1#3}
\crefmultiformat{section}{\S#2#1#3}{--\S#2#1#3}{, \S#2#1#3}{ and \S#2#1#3}

\setlength{\intextsep}{0pt} % vertical space above/below
% \setlength{\columnsep}{5pt} % horizontal space between text and figure

\begin{document}

\title{Scalable Property-Guided Program Regeneration}
\author{}


% Use cases for something like this include:
% - program repair
% - turning insecure code into secure code by removing side-effects
% - transforming a program in language A to language B
% - turning a program into a more idiomatic version of the same language
% - having a program use a different API
% - have a program be more amendable to parallelization
% - have a program be more amendable to further analysis or transformation

\begin{abstract}
  Software evolution tasks---like security hardening, porting critical components to safer 
  languages, or refactoring opaque legacy code---are commonplace, but as brittle and time-consuming as ever.
  Towards their automation, large language models (LLMs) show promise.
  However, their outputs are shaped by surface cues, lack semantic guarantees, and often rely on brittle prompting strategies.
  This paper presents \sys, a system for controllable program regeneration that
  combines declarative property constraints with LLM-guided synthesis.
  Unlike
  prior approaches, \sys treats the input program as an untrusted artifact and
  explicitly projects it into a set of verifiable properties, such as
  the program's input/output behavior, execution traces, or interaction with external data stores.
  These properties are extracted and serve the dual purpose of guiding synthesis and guardrailing synthesized outputs.
  \sys unifies established techniques and inspires new ones. % TODO: Rework this
  A preliminary evaluation shows that \sys succeeds even on tasks where state-of-the-art LLMs fail.
\end{abstract}

% Since this is a position paper (and not a tool paper), I would spend most of the paper selling the Idea, and less on the system and language. I think the examples does this well (but the language still feels a little too magical).
% The second section should probably focus on problem (program to program transformations) and the gab (related work), explaining why current approaches fall short.
% The third section should introduce our idea for a better solution, with examples. I think the core of the idea is building a knowledge base of the programs which we want to transform between, and then use (out of many) an LLM as an imperfect bidirectional analysis.
% I think the idea of bidirectional analysis is somewhat new, and handeling imperfect information in a logical system is not easy. I think we need to address why we think this is possible.
% The fourth section could contain a plan for future work: implementation and evaluation.
% The fifth section is a discussion and conclusion.

\maketitle

\section{Introduction}
\label{sec:intro}
% \begin{figure}[t]
%   % https://docs.google.com/drawings/d/1LAmdVYjfAID24eSM-hl5PRhVg9fRMJMWYETsvvcyAuU/edit?usp=sharing
%   \includegraphics[width=.9\columnwidth]{figs/kvasir_overview.pdf}
%   \caption{\textbf{\sys overview}
% Given a transformation query, and a source program, \sys extracts a minimal set
%   of properties,
%   guided by a logic engine and knowledge base.
%   It then synthesizes a new program $P'$ that satisfies the query, verifying
%   that wanted properties are present and unwanted properties are absent in $P'$.
% }
%   \label{fig:overview}
% \end{figure}

\begin{figure}[t]
  % https://docs.google.com/drawings/d/1ozMu2B0RUhyLWC_rM6GLBrioov80-M06CBqYRAhCk18/edit
  \includegraphics[width=.7\columnwidth]{figs/kvasir_projection.pdf}
  \caption{\textbf{Property projection and verifiable regeneration in \sys.}
  Instead of transforming source code directly, \sys projects the original
  program into a minimal set of verifiable properties---such as input/output
  examples, system call traces, \etc.
  The regenerated implementation is then checked to
  ensure it satisfies the specified properties, providing a verifiable
  foundation for trust unlike purely prompt-based LLM workflows.}
  \label{fig:projection}
\end{figure}


% insights: modular programs, advances in LLMs, need for a strictly declarative interface

% Mention that:
% 1. They have shown great promise in program synthesis + 
% 2. They can not do negative reasoning well - 
% 3. Their output are often closely aligned to their inputs. They are gullible (susceptible to adversarial inputs). -
% 4. Difficult to verify correctness of outputs against certain properties. The
%    user cannot easily set requirements or say output should be within a range of
%    acceptance


Modern software systems evolve constantly.
Developers refactor legacy code~\cite{Fowler99,Mens04,facebook2010redesigns,dropbox2014syncengine},
adapt libraries to changing APIs~\cite{dig2005role,kula2017empiricalstudyimpactrefactoring},
translate components across languages~\cite{manzoor_cli_python,gaultier_rewrite_cpp},
% and patch security vulnerabilities~\cite{ikegami2022userefactoringsecurityvulnerability,schneier2013security_vulnerabilities}.
These transformations are often brittle, time-consuming, and require significant expertise.

Recent advances in natural-language processing, particularly large language
models (LLMs) have opened new possibilities for automating program
transformation and synthesis tasks,
making them attractive tools for software
evolution, albeit with caveats.
This flexibility has positioned them as attractive tools for software evolution
compared to traditional program synthesis techniques, which often struggle
to scale to real-world settings or across languages and require significant developer involvement~\cite{reynolds2019syguscomp,leino2016dafny,wu2023programming,dynamoth2016,cambronero2019active}.
LLMs can translate code across languages~\cite{ou2025enhancingllmbasedcodetranslation},
refactor complex modules~\cite{ziftci2025migrating},
and even generate entire components from scratch~\cite{huynh2025largelanguagemodelscode}.
However, surface-level patterns in the input shape their outputs~\cite{yang2025evaluatinggeneralizationcapabilitieslarge},
they struggle with negative constraints~\cite{hwang2024thinkpinkelephant,jiang2024llmsdreamelephantswhen},
often overfit to spurious input cues~\cite{xu2023llmfoolitselfpromptbased, wu2023deceptpromptexploitingllmdrivencode},
and lack mechanisms for enforcing precise behavioral properties on the generated code~\cite{roh2025breakthechainreasoningfailuresllms}.
As a result, developers must prompt and steer them through ad-hoc heuristics, manual trial-and-error, or high-quality (and thus hard to create) examples~\cite{khattab2023dspy,brown2020languagemodelsfewshotlearners},
leading to workflows that are difficult to audit, integrate, or systematically reason about.
Bridging this gap calls for an approach that allows developers to specify explicit semantic constraints and transformation goals, and to reason about their satisfaction in a principled way.

This paper explores the feasibility of combining declarative property
constraints with LLM-based synthesis to support \emph{property-guided program regeneration}.
The key idea is to treat the original program as an untrusted reference from
which to extract minimal, verifiable properties (\eg input-output behavior,
function signatures, program traces), and to synthesize a new implementation that satisfies those
constraints without overfitting to potentially spurious details of the original source code.
The engine for this experimentation is the \sys prototype.
\sys allows users
to express transformation goals declaratively, as logical constraints over
program properties.
At a high level, given a source program and a query, \sys uses the provided
logical constraints and its internal knowledge base to extract a set of
feasible and relevant program properties.
It then prompts an LLM to synthesize
candidate programs, which are subsequently verified against the desired properties.
This approach treats program transformation as projecting the original program over key properties.
Intuitively, regeneration then leverages LLM's high-dimensional internal representation~\cite{jin2024emergent,tao2024llms,huh2024platonicrepresentationhypothesis}, 
which lifts the projection back to a concrete implementation~(\cref{fig:projection}).
% Unlike prompt-based approaches that require
% extensive curation of examples~\cite{dilhara2024unprecedented, khattab2023dspy, cummins2024donttransformcodecode},
% \sys treats the input program as an
% untrusted artifact and explicitly projects only minimal, verifiable properties
% into the regeneration process.

Three key insights shape the design of \sys.
First, modern software is highly decomposable~\cite{vfunction2024modular, isoline2018decomposition, schechter2011visualizing, breakapp:ndss:2018}, making it feasible to reason about transformations at the granularity of individual modules, libraries, or functions.
Second, the program \emph{regeneration} setting provides a unique advantage: the original program serves as a concrete ground-truth, enabling semantic comparisons and verification of the transformed output, something impossible in traditional synthesis tasks.
Third, the underlying synthesis technology---particularly LLMs---is evolving rapidly; a declarative interface can harness this progress without disrupting the framework's end user.

% Guided by these insights, \sys casts transformation as a constrained synthesis problem.
% At its core is a property-driven pipeline: users express goals as logical constraints over semantic properties, such as input/output behavior, side-effect freedom, target language, or structural modularity.
% \sys extracts a set of relevant properties, derived from its logic engine and a domain-aware knowledge base, and synthesizes a new program that satisfies the specified constraints.
% If no such program exists, \sys returns a failure explanation from the unsatisfiable core.

\heading{Rethinking program transformations}
% Here, talk about bidirectional analysis, how now having a program that extracts 
% a propoerty means that plugging it into sys will allow you to regenerate programs that hold or max/min-inimize over that property
Traditional transformation frameworks typically apply a one-way mapping: 
a program is analyzed to detect issues or features, and, separately, 
a hand-written rule or heuristic is applied to transform it. 
\sys enables a fundamentally different, \emph{bidirectional} view. 
Once an analysis can \emph{extract} a property,
that same analysis, when plugged into \sys's declarative query language and 
verification loop, can be used to \emph{regenerate} programs that 
satisfy, minimize, or maximize that property. 
This shifts program analyses from passive diagnostics into \emph{active drivers} 
of change: any property extractor becomes, effectively, a transformation oracle. 
This is not all, as 
its also possible to morph the extracted properties,
treating them as intermediate representations, thus further increasing 
the transformation space.
% The result is an extensible ecosystem where existing analyses not only tell us 
% what is wrong or suboptimal, but also allow us to automatically create 
% semantics-preserving, property-optimized alternatives.

% Leverages insights: (1) modern applications highly modular (2) the problem of LLM-assisted program transformations needs to be transformed in a way that a ground truth is readily available: the original program
% (3) towards the generality and longevity of this solution the interface needs to be purely declarative, to allow independent progress of the underlying components to give automatic benefits

% \heading{Contributions}
% The paper's contributions are:
% \begin{itemize}
%  \item A property-aware transformation framework, combining logic-based reasoning, and LLM-assisted program synthesis~(\cref{sec:design});
%  \item A declarative interface and accompanying DSL for program transformation, allowing users to express semantic goals as logical queries over properties of the regenerated program~(\cref{sec:dsl});
%  \item A verification architecture that checks synthesized programs against the specified properties, providing feedback for refinement~(\cref{sec:verification});
%  \item An empirical evaluation demonstrating \sys's feasibility across transformation scenarios~(\cref{sec:evaluation}).
% \end{itemize}

% \heading{Availability}
% The \sys early-stage prototype in available as an open-source MIT-licensed artifact at:
% \begin{center}
%   \url{https://github.com/blinded}
% \end{center}



\section{Point Solutions}
\label{sec:problem}

Consider a complex application, like the one
sketched in \cref{fig:ex-large-app}.
This single codebase encompasses different transformation needs.
For example, a developer going through older parts of the codebase 
might realize that many functions that accept user-controlled data are susceptible to buffer-overflow attacks.
Later, reflecting on the recently added JavaScript scripting component used for player-made extensions, it becomes clear
that these functions might be better moved entirely into the sandboxed runtime.
Furthermore, the development team would like to identify functions that could 
be broken down further to assist with performance profiling.

\heading{The state of the art and practise}
Right now, a developer has access to a myriad of different approaches 
to attack the above problems, but all come with shortcomings.
Code quality tools~\cite{avgustinov2016ql, Fowler99,Mens04,Myers16} and specialized transformation systems might be able to detect 
code-smells or certain classes of vulnerabilities but are often very highly 
tied to their target language.
As the programming-language landscape is becoming increasingly diverse,
and multiple different languages are runtimes coexist in a single system,
these limitations are becoming hard to ignore.
But even by detecting improvement opportunities, it still falls on the development team to implement them.
Program synthesis could be an attractive avenue that allows 
the developer to overcome the language barrier by synthesizing a new implementation that fits the refined specification.
However, the ever-present limitation of traditional program synthesis techniques~\cite{jha2010oracle, raza2018disjunctive, singh2016blinkfill,wu2023programming, harp:ccs:2021, yaghmazadeh2018automated} is their
difficulty to scale beyond narrowly-defined computational domains.
Statistical techniques like LLMs show promise in addressing this scalability barrier.
However, they come with no shortage of well-studied shortcomings~(\cref{sec:intro}).
An LLM could in principle be tasked with performing all the aforementioned transformations, and
there have been systems that provide ranging amounts of control of LLM-generated 
programs~\cite{huang2023anplnaturalprogramminginteractive,li2025mccoderstreamliningmotioncontrol,barua2025pygencollaborativehumanaiapproach, tihanyi2025new},
but there is a large gap of a unifying framework that identifies 
key parts of the problems and applies LLMs in a way that underlines their strengths,
end-users to steer their output, and---more importantly---be aware when 
their outputs are \emph{wrong}.


% % Related work that fails to address the problem
% \heading{Program synthesis}
% Program synthesis research spans a rich space of techniques.
% Classical techniques emphasize correctness and
% interpretability, synthesizing programs from specifications~\cite{alur2013syntax, feser2015synthesizing, gulwani2011automating,leino2016dafny},
% type or syntax constraints \cite{polikarpova2016program,reynolds2019syguscomp},
% or examples~\cite{jha2010oracle, raza2018disjunctive, singh2016blinkfill,wu2023programming},
% which are provided either by users or automatically inferred~\cite{cambronero2019active,harp:ccs:2021}
% These works often target narrowly
% defined domains such as string manipulation~\cite{harp:ccs:2021} or data migration
% \cite{yaghmazadeh2018automated} and focus on ensuring provable guarantees.
% More recently, LLM-based methods~\cite{austin2021program, chen2021evaluating}
% explore broad-domain code generation via prompt-based conditioning.
% While flexible, these models are prone to hallucination and struggle
% with reasoning under negation or satisfying structured constraints~\cite{xu2023llmfoolitselfpromptbased, wu2023deceptpromptexploitingllmdrivencode,jiang2024llmsdreamelephantswhen,hwang2024thinkpinkelephant}.

% \sys leverages insights from both these paradigms.
% Unlike purely symbolic or purely neural approaches, it leverages LLMs within a
% constrained planning framework to guide transformations while remaining
% responsive to property-based requirements.

% \heading{Program transformations and refactoring}
% The evolution and maintenance of software systems often involve transformations
% such as refactoring~\cite{Fowler99,Mens04,Myers16}, translation, or security hardening. % TODO: Add more citations

% Tools in this space often operate via syntax-tree transformations or
% domain-specific templates. Verification-based methods such as \textsc{Dafny}
% \cite{leino2016dafny} and \textsc{CBMC} \cite{Clarke04} ensure functional correctness
% but require heavy formalization.
% Others automate migration via
% programming-by-example or interactive guidance \cite{gulwani2017program, le2017interactive}.


% \sys aims to generalize this landscape by treating transformations as
% goal-directed regenerations---rather than prescriptive rewrites, driven by
% properties such as program behaviors and architectural goals, expressed declaratively.

% \heading{Logic programming and constraint solving}
% Logic programming has long served as a foundation for reasoning in programming
% tools, offering a declarative model for expressing properties and constraints.
% Answer Set Programming (ASP), in particular, provides a rich framework for
% expressing defaults, exceptions, and optimization via stable model semantics
% \cite{Gelfond_2000, Gelfond_2002, Eiter_2009}. 
% Paradigms like ASP have been used for
% declarative program analysis \cite{benton2007interactive}, automated planning
% \cite{nguyen2020explainable, son2022answersetplanningsurvey}, and knowledge
% representation in verification and synthesis pipelines.

% \sys uses ASP as its planning back-end for the planning, decision-making
% process, while also uses its straightforward optimization capabilities.
% For each transformation task, \sys formulates the property-satisfaction problem as a logic query and uses an ASP solver to
% synthesize a feasible transformation plans.

\section{Examples}
\label{sec:example}

\begin{figure}[t]
\centering
  % https://docs.google.com/drawings/d/1zMcTurJ8twCG4BrkSUAJersbNSl5UQkogHqqg88vG9M/edit
  \includegraphics[width=.9\columnwidth]{figs/kvasir_application.pdf}
  \caption{\textbf{Applying \sys to a complex game application.}
  % The high level of modularity present in modern applications allows \sys to be applied effectively inside a codebase.
  In the graph, edges signify logical dependencies between components 
  and shaded vertices signify parts of the codebase \sys is applied to~(\cref{sec:example}).
  Dotted edges signify omitted layers or dependencies.
  }
  \label{fig:ex-large-app}
\end{figure}

Consider the game application outlined in \cref{fig:ex-large-app}.
A diversity of transformation goals arise even within a single codebase:
security hardening, cross-language migration, modernization of unsafe idioms,
and structural refactoring.

\heading{A legacy input handling function}
Let's zoom into the \ttt{cmd.c} file of the game codebase,
which handles parsing and executing user commands provided by an in-game console~(\cref{lst:ex-parse}).
This functionality is used by developers to test and debug the game, but also during regular gameplay
by game administrators or players so they can customize the game by spawning objects, changing game settings, \etc
This kind of string-handling code is often notoriously difficult to write,
and there have been many instances of buffer overflow vulnerabilities being introduced because of it~\cite{CVE-2006-3400, CVE-2006-3401, CVE-2007-5248, CVE-2019-1010043}.
\begin{listing}
\begin{minted}[]{js}
#define MAX_C 1024
char *Cmd_Args(int argc, char **argv) {
 static char args[MAX_C];
 for (int i = 1; i < argc; i++) {
  strcat(args, argv[i]);
  if (i < argc - 1) strcat(args, " "); }
 return args; }
\end{minted}
\caption{A string formatting function that concatenates command-line arguments into a single string.}
  \label{lst:ex-parse}
\end{listing}

\begin{wrapfigure}[4]{r}{.53\columnwidth}
\begin{minted}{prolog}
fsignt(p_,S):-fsignt(p,S).
graph(p_,I,O):-graph(p,I,O),
               { crash(p,I); }.
:-crash(p_,I),graph(p_,I,_).
\end{minted}
\end{wrapfigure}
The developer wants to regenerate this function to eliminate this class of vulnuerabilities.
Some realizations: because the function is pure, its behavior can be fully described by input–output examples; moreover, if a buffer overflow exists, there must be inputs that trigger it.
To the right is a query written in the \sys DSL that hardens the function 
against malicious inputs.
This query requires the regenerated program \ttt{p\_} to exhibit the same
input-output behavior on both representative inputs, but have non-faulty behavior on inputs that will cause a segmentation fault to the original program \ttt{p}.
\sys first arrives at the set of properties to extract from the
original program, given the query (capital \ttt{P} here matching both the original and regenerated program):
\{\prop{graph(P, I, O)}, \prop{fsignt(P, S)}\}, where
\prop{graph(P, I, O)} extracts the client-observable input-output behavior of the program
by executing the original program on the LLM-generated inputs and recording the outputs;
\prop{crash(p, I)} signals the input generator to provide segmentation fault inducing inputs, 
and filters those that actually do;
and \prop{fsignt(P, S)} extracts each function's signature using a language-aware parser.
After 30.4 seconds and two attempts \sys synthesizes the following program:
\begin{minted}[]{js}
#define MAX_C 1024
char *Args(int argc, char **argv) {
static char args[MAX_C];
int i; size_t remaining = MAX_C - 1;
args[0] = 0;
for (i = 1; i < argc; i++) {
  strncat(args, argv[i], remaining);
  remaining = MAX_C - strlen(args) - 1;
  if (i != argc - 1 && remaining > 0) {
    strncat(args, " ", remaining);
    remaining = MAX_C - strlen(args) - 1;
  } }
  return args; }
\end{minted}

\heading{Cross-language translation}
Building on the same source as the previous example, \sys can perform
cross-language translation.
In this scenario, the developer aims to lift input
handling logic into a sandboxed JavaScript runtime to allow controlled
developer hooks and runtime customization, while reducing the attack surface of
the C runtime.
By moving this function into the scripting environment, it
becomes easier to enforce memory safety and auditability constraints.

\begin{wrapfigure}[5]{r}{.43\columnwidth}
\begin{minted}{prolog}
language(p_, js).
graph(p_, Ijs, Ojs) :-
     graph(p, Ic, Oc),
     tr(Ic, Ijs),
     tr(Oc, Ijs).
\end{minted}
\end{wrapfigure}
The query specifies that the regenerated program \texttt{P\_} must be
implemented in JavaScript and must preserve observable behavior over a
representative set of inputs and outputs.
To bridge differences in
representation between C and JavaScript, the query invokes the \ttt{tr} plugin
to convert each input and output into an equivalen one in the target language.
Behind-the-scenes a fine-tuned LLM will perform this translation.
\sys first determines the minimal set of properties to extract from the
original function: \{\prop{graph(P, I, O)}\}.
It then, again, invokes \ttt{tr} to produce
corresponding JavaScript representations of each example input and output, such
that the translated function will reproduce identical string formatting
behavior.
After 29.4 seconds, having generated 20 translated input-output pairs, \sys synthesizes the following JavaScript function:

\begin{minted}{javascript}
function cmdArgs(argv) {
    return argv.slice(1).join(" ");
}
\end{minted}
Notice that the regenerated program has a slightly different signature than the original, 
since JavaScript arrays include built-in information about their length,
which makes the \ttt{argc} argument obsolete.
The synthesis backend had the freedom to make this change since the query did not require preserving
the function signature.

\heading{An unidiomatic C function in a physics library}
The fast inverse square root routine, originally developed for the Quake III
engine~\cite{fast_inv_sqrt}, is included in the game's physics and vector math
library as an optimization for computing normalized vectors.
The implementation
exploits type punning to manipulate IEEE floats at the bit level—a technique
that relies on undefined behavior and reduces portability:
\begin{listing}
\begin{minted}{c}
float Q_rsqrt(float number) {
 long i; float x2, y;
 const float threehalfs = 1.5F;
 x2 = number * 0.5F; y  = number;
 i  = * ( long * ) &y; // evil bit level hack
 i  = 0x5f3759df - ( i >> 1 );
 y  = * ( float * ) &i;
 y  = y * ( threehalfs - ( x2 * y * y ) );
 return y; }
\end{minted}
\caption{An unidiomatic C implementation of the fast inverse square root function popularized by the game Quake III~\cite{fast_inv_sqrt}.}
\end{listing}
The query to the right uses lines of code as a coarse metric of
idiomaticity. \sys regenerates the program, minimizing this metric while
preserving observable behavior over a set of inputs which will be generated by an LLM instance.
\begin{wrapfigure}[2]{r}{.6\columnwidth}
\begin{minted}{prolog}
graph(p_,I,O):-graph(p,I,O).
#min N: len(p_, N).
\end{minted}
\end{wrapfigure}
\sys extracts the set of properties \{\prop{graph(P, I, O)}, \prop{len(P, N)}\}
from the original program
the captures captures the input-output behavior on a generated set of
inputs.
In this case, where the goal is to optimize an aspect of the program---its length---\sys
re-prompts the model to regenerate the program until it can make no further
improvements or observes no difference after two consecutive regenerations.

After 15.2 seconds and three iterations, \sys synthesizes the following idiomatic and portable version:
\begin{minted}{c}
#include <math.h>
float Q_rsqrt(float number) {
    return 1.0f / sqrtf(number); }
\end{minted}
The regenerated implementation is easier to verify, portable across compilers, and avoids undefined behavior.

\heading{A monolithic gameplay function}
Consider a JavaScript function in the game's scripting environment that
retrieves and displays a player's saved inventory from a local SQLite database~(\cref{listing:monolithic-sql}).
The function combines database initialization and query execution in a single
block of logic:

\begin{listing}
\begin{minted}{javascript}
function getInventory(playerId) {
const db = new Database("game.db");
const rows = db.prepare("SELECT
           item FROM inventory
           WHERE player_id = ?").all(playerId);
return rows.map(row => row.item); }
\end{minted}
\caption{A monolithic function that retrieves a player's inventory from a SQLite database.}
\label{listing:monolithic-sql}
\end{listing}

Bundling the database connection logic with query execution has architectural
and performance implications. In addition, systems that support sandboxing or
automatic distribution benefit from further decomposition of such functions
into composable components~\cite{Towards_Modern_Ghemaw_2023, vasilakis2019ignis, vasilakis2018breakapp}.

\begin{wrapfigure}[5]{r}{.60\columnwidth}
  \begin{minted}{prolog}
db('game.db').func(f1).func(f2).
sql_trc(p_,I,T):-sql_trc(p,I,T),
                  graph(p,I,_).
graph(call(f2,call(f1),I),I,O):-
                  graph(p,I,O).
  \end{minted}
\end{wrapfigure}

Given the query to the right, \sys generates a program that consists of two
functions whose composition is equivalent to the original implementation and
that preserve both input-output behavior and SQL trace properties (where a trace records
the sequence of queries executed against the database).

\sys wraps the Node.js process with monitors that extract the SQL queries
issued by the original function on 24 generated inputs.
After 20.4 seconds and
two attempts, it produces two functions, $f_1$ and $f_2$, such that their
composition $f_2(f_1(), i)$ is behaviorally equivalent to \texttt{getInventory}
for each input $i$.
A final processing step renames the functions by prompting
an LLM instance.
Alternatively, the user could have supplied specific names and
signatures as additional guiding properties.

The resulting program which now consists of two functions is:
\begin{minted}{javascript}
function connectDB() {
  const sqlite = require('sqlite');
  return sqlite.open({filename: 'game.db'}); }

async function getInventory(db, playerId) {
const rows = await db.all("SELECT 
             item FROM inventory
             WHERE player_id = ?", playerId);
return rows.map(row => row.item); }
\end{minted}

\heading{Key result}
\sys is able to effectively transform all programs across the above tasks,
producing high-quality outputs that satisfy user-specified constraints.
A total
of seven property extraction/verification plugins (\ttt{graph}, \ttt{fsignt}, \ttt{crash}, \ttt{sql\_trc}, and \ttt{tr})
were required to perform the above transformations, each
contributing either a set of extracted and verified properties, or a
transformation, and a set of pre- and post-conditions that the logic engine
uses to construct the regeneration plan.

\section{System Sketch}
\label{sec:design}

\begin{wrapfigure}{r}{.4\columnwidth}
  % https://docs.google.com/drawings/d/1d0piUrtExfTtUh_RuPfJFt1uZFOBEp0k-mHKSnogu-4/edit
  \includegraphics[width=.4\columnwidth]{figs/kvasir_levels.pdf}
  \label{fig:levels}
  \caption{The four key ingredients 
  of \sys that can be developed in parallel.}
\end{wrapfigure}
The insights that fuel \sys's design~(\cref{sec:intro}) lead to the following key ingredients.

% The three key subsystems are:

% \begin{enumerate}
%   \item \textbf{Property Specification and Extraction}: Users define goals
%   using logical constraints over program properties (e.g., language,
% side-effect freedom, input/output equivalence). Plugins contribute analyses and
% extraction routines to populate these properties from the input program.
%   \item \textbf{Constraint-Guided Synthesis}: The framework converts property
%     constraints into structured prompts for a language model. These prompts
%     describe what must be preserved or changed, including examples and
%     declarative requirements.
%   \item \textbf{Verification and Feedback}:
%       Synthesized candidates are validated against the target properties.
%       Failures trigger retries or incremental refinements until the goals are
%       satisfied or search is exhausted.
% \end{enumerate}

% This design makes regeneration tasks programmable, composable, and extensible, without requiring developers to encode transformation logic manually.

\heading{Extensibility through plugins}
In order to maximize the applicability of the \sys framework 
towards many different kinds of transformations,
it is designed as an extensible platform rather than a monolithic tool.
All core functionality is provided by plugins, each contributing
the following functionality in the form three runtime hooks:
(1) \ttt{apply} which obtains static or dynamic properties from the original program (\eg
input-output traces, type signatures, or side-effect summaries),
(2) \ttt{verify} that will check the regenerated program against these properties (re-extracting them and comparing them to the original ones),
and
(3) \ttt{know} adds pre/post-conditions that inform regeneration planning.
The vision of \sys it to encourage community-driven growth, where specialized plugins---\eg for
security invariants or performance contracts---can coexist and interoperate
within a single regeneration framework~(\cref{sec:discussion}).

\heading{A declarative query language}
The dizzying rate of progress in the space of 
code-generating LLMs calls for an interface 
that abstracts over the specific strengths and weaknesses of specific models 
and allows the underlying implementation to advance separately from the rest of the system.
An obvious choice: a high-level, declarative language that 
allows for reasoning irrespective of the underlying synthesis backend.

The \sys query language allows one to describe transformation intent as logical constraints over program 
properties. 
These queries are resolved against a \emph{knowledge base} of extracted 
program properties and plugin-provided pre- and post-conditions that specify when an analysis is applicable, or not.
This represents the space of behaviors and invariants 
that must be preserved, eliminated or optimized.

This separation of concerns---intent expressed declaratively, execution handled
automatically---makes regeneration auditable, repeatable, and free from brittle,
manual prompt-specific tuning.

\heading{Regeneration guardrails}
Synthesis leverages an LLM as an 
(imperfect but flexible) \emph{bidirectional analysis}, capable of 
mapping between representations.

To make this work, the final ingredient is a synthesis and verification loop that turns declarative goals into trustworthy code.
Given extracted properties and a query, \sys synthesizes candidate implementations using LLMs, leveraging their flexibility and knowledge of diverse programming idioms.
Each candidate is then checked against the declared properties: does it preserve the specified behavior, meet language or security constraints, and satisfy any additional invariants?
Failures trigger retries, a refined prompt.
A success provides an auditable proof of meeting the user's intent,
at least as far as the extracted properties allow (which is still a lot more than most LLM-based systems can guarantee).

\heading{Prototype implementation}
The \sys prototype implementation uses Python v3.13,
the \ttt{pluggy} system~\cite{pluggy} to define plugin hooks,
compiles queries to the Clingo language~\cite{DBLP:journals/corr/GebserKKS14} and uses the \ttt{clasp}~\cite{gebser2007clasp}
solver to arrive at a stable model which is converted to synthesis plans. 
A total of seven plugins have been implemented (\ttt{graph}, \ttt{tr}, \ttt{len}, \ttt{sql\_trc}, \ttt{call}, \ttt{crash}, \ttt{fsignt}).
Each plugin ranges from 9 to 51 lines-of-code,
with the entire codebase being 605 lines-of-code.

\sys takes a step in this direction with its prototype benchmarks.
This suite contains tasks across several dimensions: its
ability to regenerate correct and maintainable
code, the impact of property-driven guidance,
and practical considerations around applying it
to diverse inputs. This evaluation is
preliminary and intended to illustrate
feasibility and trade-offs.

The benchmark suite comprises 37 tasks spanning language translation, obfuscation
removal, and security hardening~(\cref{tab:benchmarks}).
Inputs were drawn from established sources
like the Rosetta Code project, popular npm and PyPi packages, high-profile supply-chain attacks,
and selected obfuscated programs from the IOCCC.

A regeneration is counted as successful if the output satisfies the declared
properties and passes both functional tests (when present) and manual inspection.

\begin{table}[t]
\centering
\caption{\textbf{Benchmark Overview}. 
The N column shows the number of programs/functions from each benchmark;
the Purpose column describes the regeneration task.}
\begin{tabular}{lrll}
\toprule
Benchmark   & N  & Purpose                    & Sources \\
\midrule
RosettaCode & 16 & Cross-language translation & \cite{rosettacode} \\
Utilities   & 13 & Parity preservation        & \cite{regbench2025} \\
SSCA        & 3  & Side-effect removal & \cite{ohm2020backstabber,ev:eurosec:2022} \\
IOCCC       & 2  & Deobfuscation              & \cite{ioccc} \\
Microb/marks & 3 & See \cref{sec:example} & \cref{sec:example} \\
\midrule
  Total     & 37 &                           & \\
% Microbenchmarks & 3  & LoC & Idiomatic rewriting, modularization & This paper \\
\bottomrule
\end{tabular}
\label{tab:benchmarks}
\end{table}

\heading{Correctness results}
Overall, \sys regenerated correct code in most cases. All Rosetta Code and
utility tasks were completed successfully. For supply-chain attacks, \sys
removed malicious behaviors while preserving legitimate functionality,
confirming that treating the original source as untrusted can be effective. 

Regeneration was less reliable in obfuscated C programs: one IOCCC entry was
successfully simplified, while another failed due to incomplete semantic
understanding and inconsistent output formatting.

In microbenchmarks, \sys generated idiomatic rewrites (\eg replacing unsafe
inverse square root implementations with standard library calls) while
maintaining observable behavior.

\heading{Comparison to naive prompting}
As a baseline, we prompted a large language model with the full source code and
a natural language description of the task. For simple translation and trivial
refactoring, this approach often succeeded. However, it frequently failed in
cases requiring property preservation without leaking implementation details. 

For example, in the malicious supply-chain benchmarks, naive prompting
preserved credential exfiltration in regenerated code, as the code 
was constructed in a way to appear as part of the original library's core functionality.
For deobfuscation tasks, obfuscation techniques that were meant to disorient 
humans (\eg renaming a function that performs addition \ttt{minus})
were equally unintepretable by the LLM, leading to obviously incorrect regenerations.
Furthermore, in the idiomatization task the LLM overfits 
to the original source code and maintains unidiomatic details (\eg bit-level manipulation)
in the regenerated program.
Highlights from this preliminary evaluation can be found in \cref{appendix:samples}.

% These results support the claim that \sys's planning logic---driven by explicit
% property extraction and knowledge-base reasoning---yields safer and more
% controllable transformations than prompt-only LLM-based systems.


\section{More Challenges}
\label{sec:limitations}

The so-far 
described subsystems~(\cref{sec:design}) can be combined to solve all transformation
goals in the snippets shown so far~(\cref{sec:example}).
Scaling these techniques further, however, poses more challenges and uncovers implications.


\heading{Trust model and correctness}
\sys
does not provide formal guarantees
of semantic equivalence
to the original program.
Instead,
correctness is defined relative to a set of enforced properties.
This means that correctness is only as strong as the property definitions and associated verifiers.
In the presence of underspecified or unverifiable goals
regenerated code
may exhibit unanticipated behavior,
even if it passes all checks. 

\heading{LLM limitations}
The generative synthesis phase
is subject to the inherent variability and failure modes
of large language models.
These include hallucinations,
sensitivity to prompt phrasing,
and inconsistency
under minor input changes.
Right now, in cases where the system finds no satisfactory candidate, regeneration fails,
but mitigating these risks, even partially will 
require co-design between the property extraction and synthesis backend~\cite{banerjee2025crane}.

\heading{Deployment scenarios}
\sys supports a range of deployment scenarios.
It is particularly well-suited for use during maintenance and auditing phases, where developers seek to refactor or replace components, especially when the original code is difficult to understand, modify, or is unavailable and the component exists only as a binary.
It can also assist during development, for instance when integrating
third-party modules that must be adapted to local conventions or hardened
against security vulnerabilities.
% For example, a developer can regenerate a C library as idiomatic
% JavaScript while preserving input-output equivalence, or decompose a monolithic function
% into modular components suitable for sandboxing.
% However, \sys is not designed for whole-program synthesis or large-scale migrations.
% Its strength lies in scoped regeneration tasks, typically at the granularity of a function, method, or small module---where transformation goals can be explicitly stated and verified in isolation.
% To this end, \sys can function not only as a standalone tool but also as a
% library, where other components can invoke it as a programmable,
% constraint-guided regeneration module.

\heading{Language-specific support}
Although some components of \sys are language-agnostic (\eg logic-based planning),
others---particularly extraction and verification plugins are not.
Supporting a new language
requires implementing language-specific analyzers and constraints.
This modularity is deliberate,
but it does limit out-of-the-box generality.
Work on a unified language representation~\cite{koppel2018onetool,bap2011,dillig2009sail},
is relevant to overcoming this limitation.
The current \sys prototype
supports Python, JavaScript, Haskell, and C. 

\heading{A benchmark suite for program regeneration} % TODO: Fix this
For research on program regeneration to flourish, it needs a common benchmark
suite that captures the diversity and difficulty of real-world transformations.
Today, there is no equivalent of SPEC for performance or Defects4J for bug
fixing---researchers and practitioners rely on ad hoc examples that are hard to compare and often
oversimplified.
This lack of a shared baseline obscures progress. 
A useful set of benchmarks should include
programs that
(1) are real and non-trivial,
(2) are written in a variety of languages, 
(3) cover a wide range of computational domains.
Each benchmark should include an original program, 
the same program that undergoes the transformation described in natural-language 
in an accompanying file, and a set of tests that verify that the transformation was successful.
Following the lead of benchmarking efforts~\cite{SPEC_CPU2017, dacapo2006, koala:atc:2025}, the suite should be made open-source, community 
first, and an established technical steering committee should guide extensions and modifications towards maintaining the suite's relevance.




\section{More Transformations}
\label{sec:discussion}

% \sys supports property-guided regeneration of program fragments, with a
% particular focus on function-level rewrites. Its strength lies in combining
% symbolic reasoning and generative synthesis in a modular and interpretable
% framework. However, this design comes with inherent trade-offs.

A system in which verifying that a program satisfies a property is equivalent
to synthesizing a program that enforces it unlocks a wide range of future
opportunities for impactful program transformations, spanning domains like security,
performance, and correctness.

\heading{Security}
Property-guided regeneration can enforce strong security 
policies, such as eliminating vulnerable API calls, sandboxing 
untrusted components, or removing implicit data leaks. 
Because \sys treats the input program as untrusted, 
analyses that detect undesirable information flows or unsafe 
behaviors can be inverted into transformations that 
\emph{actively eliminate} those risks.

\heading{Performance}
Performance-guided transformations offer a compelling avenue: \sys
could optimize for runtime, memory usage, or even parallelizability, \eg
program $P\_$ should exhibit the same input-output behavior, but run twice as fast.
Inverse
transformations, such as serializing parallel programs, could serve as
a debugging or oracle mechanism in complex system settings.

\heading{Correctness}
Future extensions to \sys may incorporate richer classes of properties, such as
temporal logic and dataflow
constraints~\cite{azzopardi2023ltl,handa2021orderawaredataflowmodelparallel}.
Refactoring towards a different API or paradigm could be done by applying 
\sys incrementally to the entire codebase, with the goal of all regenerated 
components being written in the query-prescribed way, while still being compatible 
with the rest of the project.

\heading{A system-building primitive}
Beyond isolated transformations, \sys can serve as a core building block for
higher-level systems.
For instance, a reverse-engineering pipeline for
proprietary or legacy systems could use \sys to regenerate and recompose
well-behaved modules such as a networking layer or the physics engine into open-source,
repurposed applications.
\sys can become a foundation for automated system understanding, adaptation, and re-imagination.


% \heading{Dependence on property specification}
% Many of the provided guarantees rely heavily on the quality and granularity of extracted or declared properties.
% In cases where desired behaviors cannot be easily expressed using available
% predicates, or where plugins fail to extract meaningful constraints, the
% regeneration plan may be under-constrained, leading to incorrect
% outputs or incompatibilities between the regenerated program and the larger codebase.
% Taking a page from information theory, 
% and, again, leveraging the internal representations of program code and properties,
% it could be possible 



% Overall, \sys offers a flexible framework for controlled regeneration, but
% its effectiveness depends on the specificity of goals, the availability of
% property logic, and the scope of the transformation task. Its design favors
% composability and clarity over full automation, aiming to serve as a building
% block in broader refactoring, auditing, or hardening pipelines.

\sys opens the door to a new class of synthesis tools that combine symbolic
reasoning and neural generation under a unified, extensible framework.
As program synthesis systems grow increasingly reliant on LLMs, it is very much possible that the
future lies in harnessing their generative power within a framework that retains
correctness, explainability, and developer control as first-class citizens.
This description of the \sys prototype and preliminary results serves 
as a call to action.


\bibliographystyle{ACM-Reference-Format}
\bibliography{bib.bib}

\appendix

\section{Evaluation Samples}
\label{appendix:samples}
This section provides a selection of samples from the evaluation of \sys.
These instances provide some interesting insights into the capabilities of \sys, the challenges it faces.
Some examples also feature contrasts between \sys and a naive LLM-based approach.

\heading{Left Pad}
This regeneration task involves regenerating a
function that pads a string with a given character on the left side until it
reaches a specified length.

\begin{wrapfigure}[2]{r}{0.4\columnwidth}
\begin{minted}{prolog}
graph(p_, I, O) :-
graph(p, I, O).
\end{minted}
\end{wrapfigure}
The query for \sys is shown on the right and asserts the input/output behavior of the
original program is preserved in the output.
The resulting program must match the input-output behavior of the original.
The top listing shows the original \ttt{leftPad} library, and the second listing shows the output
of \sys.
Regeneration here matches the client-visible behavior of the original but misses
implementation details, such as the use of a cache for common
use cases and the logarithmic complexity of the padding operation.
This highlights opportunities for future work in performance-aware transformations.

\begin{listing}[htpb]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
'use strict';
module.exports = leftPad;

var cache = [ '', ' ', '  ', '   ', '    ', '     ', '      ', '       ', '        ', '         ' ];

function leftPad(str, len, ch) {
  // convert `str` to a `string`
  str = str + '';
  // `len` is the `pad`'s length now
  len = len - str.length;
  // doesn't need to pad
  if (len <= 0) return str;
  // `ch` defaults to `' '`
  if (!ch && ch !== 0) ch = ' ';
  // convert `ch` to a `string` cuz it could be a number
  ch = ch + '';
  // cache common use cases
  if (ch === ' ' && len < 10) return cache[len] + str;
  // `pad` starts with an empty string
  var pad = '';
  // loop
  while (true) {
    // add `ch` to `pad` if `len` is odd
    if (len & 1) pad += ch;
    // divide `len` by 2, ditch the remainder
    len >>= 1;
    // "double" the `ch` so this operation count grows logarithmically on `len`
    // each time `ch` is "doubled", the `len` would need to be "doubled" too
    // similar to finding a value in binary search tree, hence O(log(n))
    if (len) ch += ch;
    // `len` is 0, exit the loop
    else break;
  }
  // pad `str`!
  return pad + str;
}
  \end{minted}
\caption{The original \ttt{leftPad} library.}
\end{listing}

\begin{listing}[htpb]
  \begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
function leftPad(str, len, ch) {
    // Ensure the character is a string and has a length of 1
    ch = ch || ' '; // Default to space if no character is provided
    if (typeof ch !== 'string' || ch.length !== 1) {
        throw new Error('Padding character must be a single character string');
    }
    // Pad the string on the left
    while (str.length < len) {
        str = ch + str;
    }
    return str;
}
  \end{minted}
  \caption{The output of \sys, having regenerated \ttt{leftPad}.}
\end{listing}

\heading{Fast Inverse Square Root}
The goal of this regeneration task is to transform an input 
program into a more idiomatic version that retains the same functionality.
The query for \sys is shown on the right and it uses the length of the output program as a proxy towards 
more idiomatic code.

\begin{wrapfigure}[2]{r}{0.65\columnwidth}
\begin{minted}{prolog}
graph(p_, I, O) :- graph(p, I, O).
#min N : len(p_, N)
\end{minted}
\end{wrapfigure}
The fast inverse square root function is a well-known algorithm that was
popularized by its use in the Quake III Arena source code.
It computes the inverse square root of a number using bit-level manipulation and
Newton's method for fast convergence.
The original implementation is shown in \cref{lst:fast_inv_sqrt_original}.
\Cref{lst:fast_inv_sqrt_gpt} shows the output of naively regenerating the function using \gptmodel,
which retains the original's un-idiomatic use of magic numbers and bit-level manipulation.
\Cref{lst:fast_inv_sqrt_sys} has the output of \sys, which instead uses the standard library's
\ttt{sqrt} function to compute the inverse square root.

\begin{listing}[htpb]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{c}
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y  = number;
	i  = * ( long * ) &y;                       // evil floating point bit level hacking
	i  = 0x5f3759df - ( i >> 1 );               // what the fuck?
	y  = * ( float * ) &i;
	y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed

	return y;
}
\end{minted}
  \caption{The original implementation of the fast inverse square root function 
  found in the Quake III source code~\cite{fast_inv_sqrt}}
  \label{lst:fast_inv_sqrt_original}
\end{listing}

\begin{listing}[p]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{c}
#include <stdint.h> // For using int32_t

float Q_rsqrt(float number) {
    int32_t i; // Use int32_t for better portability
    float x2, y;
    const float threehalfs = 1.5F;

    // Calculate x2 as half of the input number
    x2 = number * 0.5F;
    y = number;

    // Bit-level manipulation to get an initial guess for the inverse square root
    i = *(int32_t*)&y; // Reinterpret the bits of y as an integer
    i = 0x5f3759df - (i >> 1); // Magic number and bit manipulation
    y = *(float*)&i; // Reinterpret the bits back to a float

    // First iteration of Newton's method for refining the result
    y = y * (threehalfs - (x2 * y * y));

    // Optionally, a second iteration can be uncommented for more accuracy
    // y = y * (threehalfs - (x2 * y * y)); // Second iteration

    return y; // Return the approximate inverse square root
}
\end{minted}
  \caption{The output of naively regenerating the fast inverse square root function using \gptmodel.
  Notice that the output is ostensibly idiomatic, as it still contains 
  magic numbers and bit-level manipulation.}
  \label{lst:fast_inv_sqrt_gpt}
\end{listing}

\begin{listing}[p]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{c}
float Q_rsqrt(float number) {
    return 1.0f / sqrt(number);
}
\end{minted}
\caption{The output of \sys for the fast inverse square root regeneration.}
  \label{lst:fast_inv_sqrt_sys}
\end{listing}

% TODO add security example leetlog or string-compare

\heading{String Compare}
The goal of this regeneration task is to regenerate a given
program to remove that potential security vulnerabilities or malicious behavior.

\begin{wrapfigure}[2]{r}{0.7\columnwidth}
\begin{minted}{prolog}
pure(p_).
graph(p_, I, O) :- graph(p, I, O).
\end{minted}
\end{wrapfigure}
The query for \sys is shown on the right.
\Cref{lst:string_compare_original} shows the original string compare function, which writes to a file if the
second argument is a fixed secret value.
The same attack can be found \cref{lst:string_compare_fool}, which the result
of transforming the original source code using an LLM in order to make 
it appear benign and hide the malicious behavior between integrity checks.
\Cref{lst:string_compare_sys} shows the output of \gptmodel,
after being asked to remove any malicious behavior from the original function.
It's obvious that the attack is preserved.
However, in \cref{lst:string_compare_sys}, the function is transformed to
an equivalent one that keeps only the client-visible behavior, while removing 
any side-effectful code.

\begin{listing}[htpb]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
// (a === b)? 0 : ((a < b)?  -1: 1)
module.exports = (a, b) => {
  if (b == "gbabWhaRQ") {
    require("fs").writeFileSync('./FILE', (a + b + '\n'), 'utf-8');
  } 
  return a.localeCompare(b);
}
\end{minted}
  \caption{The original string compare function, which writes to a file if the
  second argument is a fixed secret value~\cite{copeland2019frightening}.
  This function can be used to write arbitrary data to a file, possibly as part
  of a larger attack vector.}
  \label{lst:string_compare_original}
\end{listing}

\begin{listing}[p]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
const fs = require('fs');
const path = require('path');
module.exports = (a, b) => {
  // Validate types
  if (typeof a !== 'string' || typeof b !== 'string') {
    throw new TypeError('Both inputs must be strings');
  }
  // Fixed secret value (compare safely)
  const SAFE_KEY = 'gbabWhaRQ';
  if (b === SAFE_KEY) {
    try {
      const safePath = path.resolve(__dirname, 'FILE');
      // Prevent writing large input
      if ((a + b).length > 1024) {
        throw new Error('Input too long to be safely written');
      }
      fs.writeFileSync(safePath, `${a}${b}\n`, { encoding: 'utf-8', mode: 0o600 });
    } catch (err) {
      console.error('Failed to write to FILE:', err.message);
      // Might choose to rethrow or return a special value
    }
  }
  return a.localeCompare(b);
};
\end{minted}
  \caption{The same string-compare function transformed to fool
  an LLM like \gptmodel into reproducing the malicious behavior.}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
const fs = require('fs');
const path = require('path');
module.exports = (a, b) => {
  // Validate types
  if (typeof a !== 'string' || typeof b !== 'string') {
    throw new TypeError('Both inputs must be strings');
  }
  // Fixed secret value (compare safely)
  const SAFE_KEY = 'gbabWhaRQ';
  // Use a constant-time comparison to prevent timing attacks
  const safeCompare = (str1, str2) => {
    if (str1.length !== str2.length) return false;
    let result = 0;
    for (let i = 0; i < str1.length; i++) {
      result |= str1.charCodeAt(i) ^ str2.charCodeAt(i);
    }
    return result === 0;
  };
  if (safeCompare(b, SAFE_KEY)) {
    try {
      const safePath = path.resolve(__dirname, 'SAFE_FILE');
      // Prevent writing large input
      if ((a + b).length > 1024) {
        throw new Error('Input too long to be safely written');
      }
      // Use a safer method to write files
      fs.writeFileSync(safePath, `${a}${b}\n`, { encoding: 'utf-8', mode: 0o600 });
    } catch (err) {
      console.error('Failed to write to SAFE_FILE:', err.message);
      // Might choose to rethrow or return a special value
    }
  }
  return a.localeCompare(b);
};
\end{minted}
  \caption{The output of naively regenerating the string compare function using \gptmodel. The code includes the malicious behavior.}
  \label{lst:string_compare_fool}
\end{listing}

\begin{listing}[H]
  \begin{minted}[fontsize=\footnotesize, , framesep=2mm, breaklines=true]{javascript}
function stringCompare(a, b) { return a.localeCompare(b); }
\end{minted}
  \caption{The output of \sys, which has removed the side-effectful code and
  transformed the function to an equivalent one that keeps only the client-visible behavior.}
  \label{lst:string_compare_sys}
\end{listing}

\cleardoublepage

\end{document}
