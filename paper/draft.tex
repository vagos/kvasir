\documentclass[sigplan]{acmart}

% \acmSubmissionID{PAPER ID}
\renewcommand\footnotetextcopyrightpermission[1]{}
\settopmatter{printfolios=true,printacmref=false}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}

\usepackage{setspace}
\usepackage{enumerate}
\usepackage{algorithm2e}
\usepackage{algpseudocode}
\usepackage{graphics}
\usepackage{xparse} 
\usepackage{xspace}
\usepackage{multirow}
\usepackage{csvsimple}
\usepackage{balance}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{nicefrac}
\usepackage{siunitx}
\usepackage{array,framed}
\usepackage{booktabs}
\usepackage{
  color,
  soul,
  float,
  epsfig,
  wrapfig,
  graphics,
  graphicx,
  subcaption
}
\usepackage{adjustbox}
\usepackage{csquotes}
\usepackage{cleveref}
\usepackage{dirtytalk}
\usepackage{textgreek}

\def\eg{{\em e.g.}, }
\def\ie{{\em i.e.}, }
\def\etc{{\em etc.}\xspace}
\def\vs{{\em vs.}\xspace}

\newcommand{\todo}[1]{\hl{\textbf{TODO:} #1}\xspace}
\newcommand{\sys}{{\scshape Kv{\textalpha}sir}\xspace}
\newcommand{\rf}[1]{\ref{#1}}
\newcommand{\sx}[1]{(\S\ref{#1})}
\newcommand{\cf}[1]{(\emph{Cf}.\S\ref{#1})}
\newcommand{\se}[1]{\S\ref{#1}}
\newcommand{\fg}[1]{Fig.~\ref{#1}}
\newcommand{\heading}[1]{\vspace{2pt}\noindent\textbf{\emph{#1}}:\enspace}
\newcommand{\ttt}[1]{\mintinline[fontsize=\normalsize, breaklines, breakafter=-, bgcolor=white]{javascript}{#1}}
\newcommand{\xxx}{\colorbox{red!30}{xxx}\xspace}

\crefformat{section}{\S#2#1#3}
\crefmultiformat{section}{\S#2#1#3}{--\S#2#1#3}{, \S#2#1#3}{ and \S#2#1#3}

\begin{document}


\title{\sys: Controllable Program Regeneration}
\author{Evangelos Lamprou}


% \sys is a framework for regenerating programs.
% \sys accepts a variety of wanted program properties that should be preserved after regeneration.
% \sys also takes a set of guiding properties that will be given as input to the regeneration component.
% Then, \sys will regenerate the program to satisfy the wanted properties while preserving the guiding properties.
% \sys can be used for source to source transformation, program repair, (original code can be: insecure, slow, proprietary, wrong, bad context, different language, non-idiomatic).
% \sys uses a plugin architecture that allows extending it with program property extractors (IO pairs, CFG, AST, execution traces, execution time, etc.).
% The regeneration component can be extended with different regeneration algorithms (e.g., genetic programming, symbolic execution, LLM, etc.).

% Use cases for something like this include:
% - program repair
% - turning insecure code into secure code by removing side-effects
% - transforming a program in language A to language B
% - turning a program into a more idiomatic version of the same language
% - having a program use a different API
% - have a program be more amendable to parallelization
% - have a program be more amendable to further analysis or transformation

\begin{abstract}
\end{abstract}

% Given a source program and a declarative user query $f(P, P')$,
% \sys orchestrates a property-guided regeneration process.
% Adapters extract relevant properties from the original program
% using pluggable analyzers,
% which may be language-agnostic (\eg I/O tracing)
% or language-specific (\eg AST parsing),
% and may require execution environments (\eg sandboxing).
% The logic engine formulates a minimum-satisfiability (MinSAT) problem
% over the property space using a plugin-extensible knowledge base that encodes
% compatibility constraints (\eg which transformations preserve purity, which
% properties can be reused across languages).
% The synthesis engine uses these extracted properties to generate candidate
% programs, which are verified by verifier plugins.
% The result is a program $P'$ that satisfies the user's transformation goal
% while preserving required behaviors of the original program.


\maketitle

\section{Introduction}

% insights: modular programs, advances in LLMs, need for a strictly declarative interface

Modern software systems evolve constantly.
Developers refactor legacy code~\cite{Fowler99,Mens04,facebook2010redesigns,dropbox2014syncengine},
adapt libraries to changing APIs~\cite{dig2005role,kula2017empiricalstudyimpactrefactoring},
translate components across languages~\cite{manzoor_cli_python,gaultier_rewrite_cpp},
and patch security vulnerabilities~\cite{ikegami2022userefactoringsecurityvulnerability,schneier2013security_vulnerabilities}.
These transformations, are often brittle, time-consuming, and require significant expertise.

% TODO: Introduce LLMs around here
Recent advances in large language models (LLMs) have opened new possibilities for automating code transformation tasks.
LLMs can translate code across languages~\cite{ou2025enhancingllmbasedcodetranslation},
refactor complex modules~\cite{ziftci2025migrating},
and even generate entire components from scratch~\cite{huynh2025largelanguagemodelscode}.
This flexibility has positioned them as attractive tools for software evolution.
However, their outputs are shaped by surface-level patterns in the input~\cite{yang2025evaluatinggeneralizationcapabilitieslarge}.
They struggle with negative constraints (\eg \say{do not use this interface}), often overfit to spurious input cues, and lack mechanisms for enforcing precise behavioral properties on the generated code~\cite{xu2023llmfoolitselfpromptbased, wu2023deceptpromptexploitingllmdrivencode,jiang2024llmsdreamelephantswhen,hwang2024thinkpinkelephant,roh2025breakthechainreasoningfailuresllms}.
As a result, while LLMs can accelerate prototyping, developers remain unable to reliably steer or verify their correctness.

% Mention that:
% 1. They have shown great promise in program synthesis + 
% 2. They can not do negative reasoning well - 
% 3. Their output are often closely aligned to their inputs. They are gullible (susceptible to adversarial inputs). -
% 4. Difficult to verify correctness of outputs against certain properties. The
%    user cannot easily set requirements or say output should be within a range of
%    acceptance

Despite their power, LLMs and associated tooling remain fundamentally
procedural and ad hoc: developers must prompt and steer them indirectly, often
relying on brittle heuristics or manual trial-and-error to align outputs with
intent.
This process is brittle, hard to audit, and difficult to integrate into systematic workflows.
Bridging this gap calls for a declarative interface for transformation, one that allows explicit semantic constraints and transformation goals, and supports reasoning about their satisfaction.

This paper present \sys, a system for \emph{scalable program regeneration}.
\sys allows users
to express transformation goals declaratively, as logical constraints over
program properties---such as input/output behavior, side-effect freedom, target
language, trace equivalence, or modular structure.
Given a source program and
such a query, \sys extracts a minimal set of relevant properties, guided by a
logic engine and a domain-specific knowledge base, and synthesizes a new
program that satisfies the desired constraints.

The design of \sys is shaped by three key insights.
First, modern software is highly modular, making it feasible to reason about transformations at the granularity of individual components or functions.
Second, the program regeneration setting provides a unique advantage: the original program serves as a concrete ground-truth, enabling semantic comparisons and verification of the transformed output, something impossible in traditional synthesis tasks.
Third, the underlying synthesis technology---particularly LLMs---is evolving rapidly; a declarative interface allows this progress to be harnessed without disrupting the framework's end user.

Guided by these insights, \sys casts transformation as a constrained synthesis problem.
At its core is a property-driven pipeline: users express goals as logical constraints over semantic properties, such as input/output behavior, side-effect freedom, target language, or structural modularity.
\sys extracts a set of relevant properties, using a logic engine and domain-specific knowledge base, and synthesizes a new program that satisfies the specified constraints.
If no such program exists, \sys returns failure explanations derived from the unsatisfiable core.

% Leverages insights: (1) modern applications highly modular (2) the problem of LLM-assisted program transformations needs to be transformed in a way that a ground truth is readily available: the original program
% (3) towards the generality and longevity of this solution the interface needs to be purely declarative, to allow independent progress of the underlying comopnents to give automatic benefits

The paper's key contributions are:
\begin{itemize}
 \item A declarative interface and accompanying DSL for program transformation, allowing users to express semantic goals as logical queries over properties of the regenerated program;
 \item A property-aware transformation framework, combining logic-based reasoning, and LLM-backed synthesis;
 \item An empirical evaluation demonstrating \sys’s effectiveness and scalability across transformation scenarios.
\end{itemize}

\sys is evaluated across a diverse set of transformation tasks, including:
	Security hardening, by stripping latent malicious behavior while preserving intended functionality;
	Cross-language translation, by regenerating semantically equivalent programs in new languages;
	Idiomatic rewriting, by producing safer and more portable variants of legacy code;
	Modular decomposition, by restructuring monolithic components into composable parts.
\sys is able to effectively regenerate programs across these tasks, producing high-quality outputs that satisfy user-specified constraints while also discovering transformation strategies that were not immediately obvious to the authors.

\section{Example}
\label{sec:example}
\begin{figure}[ht]
  \includegraphics[width=\columnwidth]{figs/sys_overview-figure.pdf}
  \caption{\textbf{\sys overview.}
Given a transformation query, and a source program, \sys extracts a minimal set
  of properties,
  guided by a logic engine and knowledge base.
  It then synthesizes a new program $P'$ that satisfies the query, verifying
  that wanted properties are preserved and unwanted properties are avoided.
}
\end{figure}

\sys enables users to specify transformation goals declaratively.
These goals are expressed as logical constraints over properties of the
regenerated program, such as input-output equivalence, side-effect elimination,
target language, lines of code, and others.

Given a program and a query over desired properties, \sys selects a minimal set
of properties to extract from the original program, then attempts to synthesize
a new program that satisfies the query.
This process is cast as a
minimum-satisfiability (MinSAT) problem~\cite{kohli1994minimum}, optimizing for the smallest extraction
effort necessary to enable transformation.
If the query is unsatisfiable under
the constraints or transformations, \sys issues an error
message, showing the conflict.

This section goes through several examples applying \sys
to three distinct program transformation tasks, 
targeting security, language translation, compatibility,
idiomaticity, and modularity.

\heading{A compromised JavaScript library}
The \texttt{flatmap-stream} library was implicated in a high-profile
supply-chain attack that exfiltrated Bitcoin credentials~\cite{ev:eurosec:2022}.
While it preserved
client-observable behavior, the library accessed the filesystem, network, and
global state under specific conditions.
Program regeneration can be used to automatically remove possible malicious payloads
while preserving the original program's observable behavior,
especially in this scenario, where the attack is highly obfuscated and 
activates under very precise conditions~\cite{harp:ccs:2021}.
\begin{minted}[frame=lines]{js}
module.exports = function (stream, fn) {
 if (process.env.PRODUCTION) {
  const priv = copay.getKeys()?.[0]?.priv;
  if (priv && wallet.balance > 0) {
    http.request({ hostname: 'evil.com' })
        .send({ priv });
  }} return flatten(steam).apply(fn); };
\end{minted}

\begin{wrapfigure}[3]{r}{.5\columnwidth}
\vspace{-10pt}
\begin{minted}{prolog}
equal(io(P), io(P_)).
pure(P_).
\end{minted}
\end{wrapfigure}
A program written in the \sys DSL to express this intent is shown.
This query requires the regenerated program \ttt{P_} to exhibit the same I/O behavior,
but forbids side-effects.
\sys first arrives at a minimal set of properties to extract from the
original program, given its knowledge base and the query.
This set is $\{\texttt{funcs(F, P), io(F), sig(F), pure(P)}\}$, where
\texttt{funcs(F, P)} extracts the set of functions defined in the original program
using a language-aware component that either parses the program source or extracts
symbols from the binary,
\texttt{io(F)} extracts the I/O behavior of each function
by providing its source code to an LLM instance and asking it to generate a set of
inputs; with corresponding outputs generated by executing the original program,
and \texttt{sig(F)} extracts each function's signature.
The, \texttt{pure(P)} property means that \sys will confirm after regeneration that the original program is (obviously) pure
using static analysis.

After \xxx seconds, \sys generates the following program:
\begin{minted}[frame=lines]{js}
module.exports = function(stream, fn) {
  return stream.map(fn); };
\end{minted}


Building on the same source, \sys can be used for cross-language
translation. 
Here, the goal is to regenerate a semantically equivalent version
of \texttt{flatmap-stream} in Haskell, to enable integration with a
Haskell-based pipeline or facilitate formal reasoning.

\begin{wrapfigure}[3]{r}{.5\columnwidth}
\vspace{-10pt}
\begin{minted}{prolog}
equal(io(P), io(P_)).
language(P_, haskell).
\end{minted}
\end{wrapfigure}
The query requests preservation of I/O behavior and translation to Haskell. The
logic engine deduces that extracting I/O traces and the function signature is
sufficient; the knowledge base automatically associates the target language
\texttt{Haskell} with purity.
\sys transforms each extracted I/O example into an equivalent one in Haskell (\eg 
the pair $\langle\texttt{([1,[2,3]], (x)=>x+1)}\to\texttt{[2,3,4]}\rangle$ 
becomes $\langle(\texttt{[1, [2,3]], Js("(x)=>x+1"))}\to\texttt{[2,3,4]}\rangle$).
Finally, it provides the transformed examples to a new LLM instance, prompting it
to generate a Haskell program that satisfies the same I/O behavior.
After \xxx seconds, having generated \xxx I/O pairs, \sys produces the following
Haskell program:
\begin{minted}[frame=lines]{haskell}
flatmap :: (a -> b) -> NestedList a -> [b]
flatmap f (Elem x) = [f x]
flatmap f (List x) = concatMap (flatmap f) x
\end{minted}

\heading{An unidiomatic C program}
The fast inverse square root routine from the Quake III
engine~\cite{fast_inv_sqrt}
is a classic example of performance-oriented low-level programming.
The original implementation exploits type punning to manipulate IEEE
floats at the bit level---an optimization that relies on undefined behavior:

\begin{minted}[frame=lines]{c}
float Q_rsqrt(float number) {
 long i; float x2, y;
 const float threehalfs = 1.5F;
 x2 = number * 0.5F; y  = number;
 i  = * ( long * ) &y; // evil bit level hack
 i  = 0x5f3759df - ( i >> 1 );
 y  = * ( float * ) &i;
 y  = y * ( threehalfs - ( x2 * y * y ) );
 return y;
}
\end{minted}

The following query for \sys uses lines-of-code a coarse metric of
idiomaticity. \sys will regenerate the program, minimizing this metric, while
preserving its I/O behavior.
\begin{wrapfigure}[3]{r}{.5\columnwidth}
  \vspace{-5pt}
  \begin{minted}{prolog}
equal(io(P), io(P_)).
#min len(P_).
  \end{minted}
\end{wrapfigure}
\sys extracts the set of properties $\{\texttt{sig(F)}, \texttt{io(F)}\}$ from the original program, where \texttt{sig(F)} is the
signature of the function (including its name, return type, and arguments), and \texttt{io(F)} is the I/O behavior of the function
on a set of generated inputs.
In this case, where it is instructed to optimize an aspect of the program, \sys will re-prompt
the model to regenerate the program until no improvements are made or there is a negligible difference after two consecutive iterations.
After \xxx seconds, and \xxx iterations, \sys produces the following program:
\begin{minted}[frame=lines]{c}
#include <math.h>
float Q_rsqrt(float number) {
    return 1.0f / sqrtf(number);
}
\end{minted}
The regenerated version is easier to verify, portable across compilers, and
avoids undefined behavior.
A user could have also provided performance requirements using 
the \ttt{time(P)} property to further guide the regeneration process.
In this case, \sys would have run the two functions inside a tight loop and 
would have aborted the regeneration process if the performance of the generated
program was not within an acceptable user-defined threshold.

\heading{A rigid music database application}
Consider a JavaScript application that retrieves and displays a user's music
collection from an SQLite database~\cite{codewithsadeemusicplayer, beets}:

\begin{minted}[frame=lines]{js}
function getAlbumsByArtist(artist) {
  const db = new Database("music.db");
  const rows = db.prepare("SELECT album
  FROM songs WHERE artist = ?").all(artist);
  return rows.map(row => row.album); }
\end{minted}

Having the database initialization being in the same function as 
the database access has architectural and performance implications.
In addition, there exist systems that can benefit from further decomposition
of an application towards automatic distribution, parallelization or security~\cite{Towards_Modern_Ghemaw_2023, vasilakis2019ignis, vasilakis2018breakapp}.
\begin{wrapfigure}[5]{r}{.7\columnwidth}
  \vspace{-10pt}
  \begin{minted}{prolog}
db('music.db').
equal(trace(P,sql),trace(P_,sql)).
func(F1). func(F2).
equal(F2(F1, _), P).
\end{minted}
\end{wrapfigure}
\sys, given the query to the right, is instructed 
to generate program that consists of two functions,
whose composition is equivalent to the original program, and feature 
the same I/O and trace properties (a trace here being the sequence of SQL 
queries transmitted to the database).
\sys wraps the node process with monitors that extract the SQL queries 
sent to the database for \xxx generated inputs.
Then, after \xxx seconds and \xxx attempts, it arrives at two functions $f_1$, and 
$f_2$, where their composition $f_2(f_1, \_)$, is equivalent to the original \ttt{getAlbumsByArtist} function across these inputs.
A final processing step renames functions $f_1$ and $f_2$ by prompting an LLM instance.
Alternatively, the user could have provided specific signatures and names for each 
functions as an additional guiding property.
The resulting program is:
\begin{minted}[frame=lines]{js}
function connectDB() {
 const sqlite = require('sqlite');
 return sqlite.open({filename: 'music.db'}); 
}
function getAlbumsByArtist(db, artist) {
 const rows = await db.all("SELECT album
 FROM songs WHERE artist = ?", artist);
 return rows.map(row => row.album); }
\end{minted}

% \heading{Key Results}
% \sys is able to effectively transform programs across a variety goals.

\section{\sys Design}

\sys is a system for program regeneration: given an input program and a set of
behavioral, structural, or syntactic properties, it synthesizes a new program
that satisfies a specified subset of those properties. The system treats
regeneration as a goal-driven process, guided by explicit property
specifications and a symbolic planner that structures the search space for a
backend synthesizer.
At a high level, \sys operates in four phases: (1) property extraction, (2)
plan construction, (3) program synthesis, and (4) verification. These phases
interact through a shared representation of the program and its transformation
goals.

\heading{Property Extraction} \sys begins by analyzing the input program to
extract a collection of properties. These may describe the program’s interface
(\eg, exported functions), its operational constraints (\eg, disallowing
filesystem access), or its structure (\eg, use of a particular API or
programming idiom). While some properties are derived from generic analyses
applicable across languages, others are tailored to the specifics of the input
program’s language and runtime model.

\heading{Plan Construction} The extracted properties, together with
user-provided regeneration goals, are passed to a planning component. The
planner constructs a transformation plan that specifies which properties must
be preserved, which may be relaxed, and what target conditions must be achieved
in the output program. This plan captures a symbolic view of the regeneration
task and constrains the synthesis phase accordingly.

\heading{Synthesis} Guided by the transformation plan, \sys synthesizes a
candidate program intended to satisfy the specified constraints. Synthesis is
treated as a generative process constrained by the plan’s logic---only programs
that respect the specified properties and behavioral goals are considered valid
candidates. This phase can incorporate both local and global reasoning about
the structure and semantics of the output.

\heading{Verification and Feedback} The final phase verifies that the
synthesized program satisfies the required properties. If verification
fails---due to a violated constraint or behavioral divergnce---\sys uses this
failure as a signal to refine the plan or resample the synthesis step. This
forms a feedback loop: planning, synthesis, and verification interact until a
satisfactory program is produced or the system exhausts its search.

\sys is designed to support small-scale regeneration tasks,
usually function-level rewrites.
While some components generalize across languages, others---particularly
property extraction and transformation strategies---must be adapted to the
syntactic and semantic characteristics of the target language.

\section{Property Language and Extraction}

\sys represents program characteristics as symbolic \emph{properties}, drawn from a formal language of first-order predicates. These properties describe aspects of the input program and serve as regeneration constraints for the output. They form the basis of both planning and verification.

\paragraph{Property Predicates.}
Each property is represented as a logical predicate over the program symbol $p$. Common examples include:
\begin{itemize}
  \item \texttt{language}$(p, \texttt{javascript})$: the input program is written in JavaScript.
  \item \texttt{signature}$(p)$: the program exposes a well-formed function signature.
  \item \texttt{no\_network}$(p)$: the program performs no network operations.
\end{itemize}

Properties are classified into three categories:
\begin{itemize}
  \item $\mathsf{goal}(X)$: the user or system requires $X$ to hold in the regenerated program.
  \item $\mathsf{can}(X)$: the system is capable of extracting or inferring $X$ from the input.
  \item $\mathsf{do}(X)$: $X$ is selected for enforcement and will be preserved or regenerated.
\end{itemize}

\paragraph{Planning over Properties.}
The logic engine determines the set of active properties to enforce by solving a constrained optimization problem over $\mathsf{do}(\cdot)$. It satisfies the following constraints:
\begin{align*}
  \mathsf{goal}(X) &\Rightarrow \mathsf{do}(X) &\text{Goals must be satisfied} \\
  \mathsf{do}(X) &\Leftarrow \mathsf{can}(X) &\text{Apply only extractable properties}
\end{align*}

Additionally, the system maximizes the number of enforced properties: % TODO: Explain why
\[
\text{maximize} \quad |\{ X \mid \mathsf{do}(X) \}|
\]

\paragraph{Plugin-Defined Rules.}
Plugins contribute domain-specific inference rules and constraints. For example, a plugin for JavaScript-to-Haskell translation may define:
\begin{align*}
\mathsf{can}(\texttt{translate}_{\texttt{js} \rightarrow \texttt{hs}}(p)) & \\
\mathsf{do}(\texttt{translate}_{\texttt{js} \rightarrow \texttt{hs}}(p)) &\Rightarrow \mathsf{do}(\texttt{language}(p, \texttt{haskell})) \\
\mathsf{do}(\texttt{translate}_{\texttt{js} \rightarrow \texttt{hs}}(p)) &\Rightarrow \mathsf{language}(p, \texttt{javascript})
\end{align*}

Another plugin might contribute $\mathsf{can}(\texttt{signature}(p))$, indicating that the function signature can be extracted.

\paragraph{Axioms and Domain Knowledge.}
The logic engine also supports domain-wide axioms. For example:
\[
\mathsf{do}(\texttt{language}(p, \texttt{haskell})) \Rightarrow \mathsf{do}(\texttt{pure}(p))
\]
This captures the assumption that programs written in Haskell are pure by default. Such axioms enrich the reasoning process and allow inferred properties to trigger downstream constraints or synthesis behaviors.

\paragraph{Extensibility.}
\sys’s property extraction is decentralized: plugins contribute $\mathsf{can}(\cdot)$ and reasoning rules, while the core planner resolves which properties to enforce based on goals, capabilities, and global constraints. This modularity allows language-specific analyses to coexist with general-purpose reasoning in a unified planning layer.

By treating properties as planning primitives, \sys unifies static analysis, user intent, and regeneration constraints in a common symbolic framework. This design enables precise and interpretable control over the regeneration process.

\section{Synthesis Plan}

\sys performs regeneration through a structured synthesis plan that combines symbolic reasoning over program properties with targeted, language-model-guided code generation. The system is designed to support small-scale regeneration tasks—typically at the level of individual functions—where precision and control are critical. By focusing on localized rewrites rather than wholesale program replacement, \sys enables composable transformations that scale across large codebases when applied judiciously.

\paragraph{From Properties to Plan.}
The synthesis process begins with a set of enforced properties $\{ X \mid \mathsf{do}(X) \}$ selected by the planner (§\ref{sec:property-language}). These properties reflect both user goals (e.g., removing side effects, translating to a different language) and structural characteristics of the input program that should be preserved. The planner constructs a transformation plan that specifies, for each relevant unit of code (typically a function), what constraints must hold in the regenerated version.

For instance, a plan for regenerating a specific function might include:
\begin{itemize}
  \item $\mathsf{do}(\texttt{language}(f, \texttt{haskell}))$ — the function must be rewritten in Haskell,
  \item $\mathsf{do}(\texttt{pure}(f))$ — the function must be side-effect-free,
  \item $\mathsf{do}(\texttt{signature}(f))$ — the original function signature must be preserved.
\end{itemize}
These constraints are scoped to the transformation unit and inform the synthesis phase directly.

\paragraph{LLM-Guided Regeneration.}
Each synthesis task is delegated to a language model guided by a structured prompt. The prompt is constructed by composing fragments contributed by active plugins, each of which has access to the current plan and can contribute natural language or code examples relevant to its domain. For example:
\begin{itemize}
  \item A signature plugin may contribute: \emph{“The output should implement a function \texttt{normalize(str: string): string}.”}
  \item A purity plugin may add: \emph{“Avoid all side effects, including file system or network operations.”}
  \item A language plugin may prepend: \emph{“Translate this JavaScript function into idiomatic Haskell.”}
\end{itemize}

These fragments are combined with a representation of the input function—possibly abstracted to suppress undesirable behavior—and submitted to the LLM as a constrained regeneration task.

\paragraph{Locality and Compositionality.}
The emphasis on function-level regeneration serves two purposes. First, it limits the scope of transformation, reducing the risk of unintended behavioral changes. Second, it enables \sys to reuse synthesized components across broader program contexts, composing regenerated units into a coherent whole. This design supports partial regeneration: some functions may be left unchanged, others regenerated under different plans.

\paragraph{Constraint-Guided Generation.}
While synthesis is delegated to an LLM, the planner constrains the generation space in two key ways:
\begin{enumerate}
  \item The prompt reflects only valid transformations under the current plan.
  \item Candidate outputs are verified post hoc against the enforced properties (§\ref{sec:verification}), and failures result in rejection or plan revision.
\end{enumerate}
This hybrid model balances flexibility with rigor: the LLM provides diversity and fluency, while the planner ensures adherence to property-based constraints.

\paragraph{Incremental and Adaptive Planning.}
If a candidate program fails verification, \sys does not blindly retry. Instead, it may refine the plan: relaxing soft constraints, prioritizing alternatives, or invoking different plugin strategies. This incremental approach avoids overfitting to invalid candidates and supports fallback mechanisms when regeneration proves difficult.

In sum, the synthesis plan acts as a structured contract between logical property reasoning and generative synthesis. By operating at a localized level and under clearly scoped constraints, \sys delivers regenerations that are both controlled and scalable—when applied thoughtfully and systematically.

\section{Property Verification and Feedback Loop}
\label{sec:verification}

To validate that a regenerated program satisfies the intended goals, \sys includes an explicit verification phase that checks whether the output adheres to the enforced properties in the synthesis plan. Verification serves as a structural filter: it accepts only those candidates that meet the plan’s constraints and provides feedback for refining or retrying those that do not.

\paragraph{Verification as Property Checking.}
After synthesis, \sys invokes a set of property-specific checkers. Each checker is responsible for evaluating whether a property $X$ in $\mathsf{do}(X)$ holds for the regenerated program fragment. These checkers operate at varying levels of precision—ranging from structural pattern checks to light static or symbolic analysis—and are tailored to the property type.

Examples include:
\begin{itemize}
  \item For $\mathsf{do}(\texttt{no\_network}(f))$, the checker confirms the absence of known network APIs or imports.
  \item For $\mathsf{do}(\texttt{signature}(f))$, the checker matches the regenerated function’s name, parameters, and arity against the extracted signature.
  \item For $\mathsf{do}(\texttt{pure}(f))$, the checker examines control flow and side-effecting operations to detect possible violations.
\end{itemize}

Checkers are modular and contributed by plugins. Their combined results determine whether a candidate is considered valid under the current plan.

\paragraph{Failure-Driven Refinement.}
When a candidate fails verification, \sys treats this as a feedback signal. Instead of discarding the regeneration attempt wholesale, the system uses the failure to revise or re-execute the synthesis phase. This may take several forms:
\begin{itemize}
  \item \emph{Retrying synthesis}: A fresh LLM call with the same plan but a different generation path.
  \item \emph{Adjusting the plan}: Relaxing soft constraints or reordering plugin hooks to prioritize more tractable properties.
  \item \emph{Fallback handling}: If a function repeatedly fails validation, \sys may leave the original version intact or mark it for manual inspection.
\end{itemize}

This loop provides adaptability: regeneration is not expected to succeed unconditionally, but rather to proceed incrementally under interpretable, bounded failure modes.

\paragraph{Partial Regeneration and Composition.}
\sys supports regeneration at the granularity of individual functions. If only a subset of functions can be successfully regenerated under the given constraints, the remaining ones are excluded from transformation. The output program thus consists of a composition of validated regenerated units and untouched originals.

This model supports practical application in real-world codebases, where partial improvement (e.g., replacing unsafe or deprecated functions) can be meaningful even without complete coverage.

\paragraph{Iterative, Property-Preserving Generation.}
The synthesis-verification loop respects the symbolic contract defined in the planning phase. At each iteration, the system attempts to generate a program fragment that satisfies the active $\mathsf{do}(\cdot)$ properties. Failed attempts lead to refinement, not abandonment. New candidates are synthesized with awareness of prior failures, either by adapting the plan or sampling more selectively.

The verifier interface is designed for extensibility: new properties can introduce new checkers without modifying the core regeneration pipeline.

\paragraph{Behavioral Guarantees.}
\sys does not aim to replicate the full semantics of the input program. Instead, it focuses on regenerating code that conforms to a declarative set of constraints. When a regenerated program passes verification, it is accepted as satisfying the subset of properties represented in the current plan. The system makes no claims beyond these verified constraints.

This contract-driven model supports safe, localized rewrites in domains where correctness, compatibility, or safety properties must be preserved with high confidence, even in the presence of imperfect generative models.

% TODO: Move this later maybe in implementation details
% \section{Component Interface}

% \sys adaptor, logic engine, and verifier components
% are designed to be extensible.
% These can be written in the form of plugins.
% Adding a new to-be-preserved (or avoided) property involves 
% creating a new adaptor function that extracts that property from the given 
% program together with the logical pre-conditions that need to hold 
% for it to be extractable, and a new verifier function that checks whether the
% property is preserved in the regenerated program or \say{unknown}.
% Each part of the plugin can produce logical atoms or rules which are fed to the \sys 
% logical engine and can influence the regeneration process.

\section{Evaluation}

We evaluate \sys along three axes:

\begin{itemize}
  \item[\textbf{Q1}] \textbf{Correctness and Regeneration Quality}: Does \sys preserve program behavior and produce high-quality programs?
  \item[\textbf{Q2}] \textbf{Transformation Success}: Can \sys handle a diverse set of regeneration goals?
  \item[\textbf{Q3}] \textbf{Planning Efficiency \& Precision}: Does minimizing extracted properties help regeneration succeed faster and more reliably?
\end{itemize}

\subsection{Benchmarks \& Methodology}

We evaluate \sys on six benchmark suites, summarized in \cref{tab:benchmarks}.
These benchmarks include popular codebases from real-world package ecosystems, obfuscated or malicious components, and handcrafted microbenchmarks that reflect the use cases discussed in \cref{sec:example}.

\begin{table}[h]
\centering
  \caption{\textbf{Benchmark summary}. 
  Benchmark programs have been sourced from several sources.
  The $N$ column shows the number of programs/functions from each benchmar.
  }
\begin{tabular}{llrl}
\toprule
Benchmark                                               & Description                    & $N$ & Source \\
\midrule
  Rosetta Code                                          & Programming tasks              & 5 & \cite{rosettacode} \\
  npm utilities                                           & Utilities from npm             & 10 & \cite{regbench2025} \\
Python utilities                                        & Utilities from PyPi            & 1 & \cite{regbench2025} \\
  SSCA                                                    & Sneaky SSAs    & 3 & \cite{ev:eurosec:2022, es1, ohm2020backstabber} \\
  IOCCC                                                   & Obfuscated C code              & 2 & \cite{ioccc} \\
Microbenchmarks                                         &          & 3    & \\
  \hspace{.5em} \ttt{flatmap-stream}                      & Secure regeneration            &      & \cite{es1}  \\
  \hspace{.5em} \ttt{Q_rsqrt}                             & C refactoring        &      & \cite{fast_inv_sqrt}  \\
  \hspace{.5em} \textsf{MusicDB}                          & Modularization           &      & \cite{codewithsadeemusicplayer} \\
\bottomrule
\end{tabular}
\label{tab:benchmarks}
\end{table}

Each task consists of an input program, a \sys query expressing desired properties, and a test suite or functional oracle.

\subsection{Q1: Correctness and Regeneration Quality}

We evaluate correctness using developer-made test suites 
shipped with the original software components as well as by manually inspecting
the regenerated source code and report on correctness and the other query target metrics.
When no test suite is available, we only do manual inspection.

\begin{table}[h]
  \centering
  \caption{Correctness: Percentage of tasks passing all I/O tests.}
  \begin{tabular}{lc}
    \toprule
    Benchmark & \sys Pass Rate \\ 
    \midrule
    Rosetta Code & \xxx/\xxx  \\
    npm Utilities & \xxx/\xxx \\
    Python Utilities & \xxx/\xxx \\
    SSCA & \xxx/\xxx  \\
    IOCCC & \xxx/\xxx  \\
    Microbenchmarks & \xxx/\xxx  \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Q2: Transformation Success}

We test whether \sys meets transformation goals across different categories.
Each row corresponds to a class of transformation query (e.g., removal of side effects, modular decomposition).
We count success when the generated program meets all stated properties and passes correctness checks.
\sys consistently succeeds at expressing non-trivial goals that GPT-4 baseline prompts often fail to satisfy.

\subsection{Q3: Planning Efficiency \& Precision}

To evaluate the impact of \sys's property planning, we compare it against a GPT-4 baseline that performs prompt-only rewriting without explicit access to guiding properties.

We consider two criteria for each regenerated program:

\begin{itemize}
  \item \textbf{Wanted Property Satisfaction:} Does the output program satisfy all positive properties declared in the query (\eg \texttt{pure}, \texttt{language(haskell)})?
  \item \textbf{Unwanted Property Avoidance:} Does the output avoid introducing disallowed behaviors (\eg side effects, global state, unsupported language features)?
\end{itemize}

\begin{table}[h]
  \centering
  \caption{
    Planning precision: Number of tasks where positive properties are satisfied ($P_p$) and negative properties are avoided ($P_n$).
  }
  \begin{tabular}{lcc}
    \toprule
    Variant & $P_{p}$ & $P_{n}$  \\
    \midrule
    \sys & \xxx & \xxx \\
    GPT-4 & \xxx & \xxx \\
    \bottomrule
  \end{tabular}
\end{table}

\sys consistently satisfies more of the declared properties while avoiding unintended behaviors. For instance, in the \texttt{flatmap-stream} benchmark, GPT-4 often preserved malicious side effects when the code appeared innocuous, whereas \sys generated provably pure rewrites by treating the source as untrusted and grounding regeneration in I/O behavior alone.
Across all benchmarks, the planning step completes in under \xxx ms on average.
% TODO: re-add this
% adding negligible latency compared to synthesis time. Moreover, by minimizing
% the number of properties to extract and verify, planning reduces the total time
% and resource usage of the regeneration pipeline.

These results support the claim that \sys's planning logic---driven by explicit
property extraction and knowledge-base reasoning---yields safer and more
controllable transformations than prompt-only LLM-based systems.

\section{Related Work}

\heading{Program Synthesis}
Program synthesis research spans a rich space of techniques.
Classical techniques emphasize correctness and
interpretability, synthesizing programs from specifications~\cite{alur2013syntax, feser2015synthesizing, gulwani2011automating},
type constraints \cite{polikarpova2016program},
or examples \cite{jha2010oracle, raza2018disjunctive, singh2016blinkfill}.
These works often target narrowly
defined domains such as string manipulation~\cite{harp:ccs:2021} or data migration
\cite{yaghmazadeh2018automated} and focus on ensuring provable guarantees.
More recently, LLM-based methods~\cite{austin2021program, chen2021evaluating}
explore broad-domain code generation via prompt-based conditioning.
While remarkably flexible, these models are prone to hallucination and struggle
with reasoning under negation or satisfying structured constraints~\cite{xu2023llmfoolitselfpromptbased, wu2023deceptpromptexploitingllmdrivencode,jiang2024llmsdreamelephantswhen,hwang2024thinkpinkelephant}.

\sys leverages insights from both these paradigms.
Unlike purely symbolic or purely neural approaches, it leverages LLMs within a
constrained planning framework to guide transformations while remaining
responsive to property-based requirements.
This design combines
the scalability of LLM-assisted program sysnthesis with the controllability and robustness of symbolic
reasoning. % TODO: focus on that \sys focuses on this specific problem domain

\heading{Program Transformations and Refactoring}
The evolution and maintenance of software systems often involve transformations
such as refactoring, translation, or security hardening. Foundational work on
refactoring~\cite{Fowler99} and its taxonomy~\cite{Mens04} characterizes the
space of behavior-preserving modifications. More recent perspectives emphasize
developer experience and usability, particularly in the context of APIs~\cite{Myers16}.

Tools in this space have largely operated via syntax-tree transformations or
domain-specific templates. Verification-based methods such as \textsc{Dafny}
\cite{Leino10} and \textsc{CBMC} \cite{Clarke04} ensure functional correctness
but require heavy formalization.
Others automate migration via
programming-by-example or interactive guidance \cite{gulwani2017program, le2017interactive}.

Kvasir aims to generalize this landscape by treating transformations as
goal-directed regenerations---rather than prescriptive rewrites, driven by
properties such as program behaviors and architectural goals, expressed declaratively.

\heading{Logic Programming and Constraint Solving}
Logic programming has long served as a foundation for reasoning in programming
tools, offering a declarative model for expressing properties and constraints.
Answer Set Programming (ASP), in particular, provides a rich framework for
expressing defaults, exceptions, and optimization via stable model semantics
\cite{Gelfond_2000, Gelfond_2002, Eiter_2009}. ASP has been used for
declarative program analysis \cite{benton2007interactive}, automated planning
\cite{nguyen2020explainable, son2022answersetplanningsurvey}, and knowledge
representation in verification and synthesis pipelines.

\sys uses ASP as its planning back-end for the planning, decision-making
process, while also uses its straighftorward optimization capabilities.
For each transformation task, \sys formulates the property-satisfaction problem as a logic query and uses an ASP solver to
synthesize a feasible transformation plans.
This enables global reasoning across program components and enforces
user-specified constraints that are difficult for neural models to respect.
In addition, it offers a level of explainability that is useful in case transformations end up incorrect.

\section{Discussion and Limitations}

\sys is designed to support property-guided regeneration of program fragments, with a particular focus on function-level rewrites. Its strength lies in combining symbolic reasoning and generative synthesis in a modular and interpretable framework. However, this design comes with inherent tradeoffs, which we discuss below.

\paragraph{Scope of Regeneration.}
\sys is not intended for whole-program synthesis or full language migration. It operates most effectively when applied to localized program units—such as individual functions, methods, or modules—where the intended behavior is reasonably self-contained and describable via explicit properties. Applying \sys to larger-scale transformations may yield incomplete results, or expose coordination challenges not addressed by the current system.

\paragraph{Dependence on Property Specification.}
The system relies heavily on the quality and granularity of extracted or declared properties. In cases where desired behaviors cannot be easily expressed using available predicates, or where plugins fail to extract meaningful constraints, the regeneration plan may be under-constrained, leading to brittle or incorrect outputs. The framework is extensible, but each new property class requires new reasoning rules, extractors, and verifiers.

\paragraph{Trust Model and Correctness.}
\sys does not provide formal guarantees of semantic equivalence to the original program. Instead, correctness is defined relative to a set of enforced properties. This means that correctness is only as strong as the property definitions and associated checkers. In the presence of underspecified or unverifiable goals, regenerated code may exhibit unanticipated behavior—even if it passes all checks.

\paragraph{LLM Limitations.}
The generative synthesis phase is subject to the inherent variability and failure modes of large language models. These include hallucinations, sensitivity to prompt phrasing, and inconsistency under minor input changes. While \sys mitigates these risks through constraint-based planning and post-hoc verification, it cannot eliminate them entirely. In cases where no satisfactory candidate is found, regeneration may fail or require manual intervention.

\paragraph{Language-Specific Support.}
Although some components of \sys are language-agnostic (e.g., logic-based planning), others—particularly extraction and verification plugins—are not. Supporting a new language requires implementing language-specific analyzers and constraints. This modularity is deliberate, but it does limit out-of-the-box generality.

\paragraph{Strategic Application.}
In practice, \sys is best used as a surgical tool: to rewrite high-risk, deprecated, or poorly understood code under explicit constraints. Its effectiveness comes from focusing effort on narrow slices of functionality where correctness matters and regeneration goals are clear. Broad, untargeted application is unlikely to yield high-quality results.

\paragraph{Future Directions.}
Several extensions could improve \sys’s capabilities. These include richer property languages (e.g., temporal or dataflow properties), tighter integration with formal verification tools, learning-guided property extraction, and cross-component reasoning for coordinated rewrites. Additionally, integrating counterfactual generation techniques could help explain why certain regeneration goals are infeasible or conflicting.

Overall, \sys offers a flexible framework for controlled regeneration, but its effectiveness depends on the specificity of goals, the availability of property logic, and the scope of the transformation task. Its design favors composability and clarity over full automation, aiming to serve as a building block in broader refactoring, auditing, or hardening pipelines.

\section{Conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bib.bib}

\end{document}
